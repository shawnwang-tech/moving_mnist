# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_data.ipynb (unless otherwise specified).

__all__ = ['PM', 'ImageSeq', 'ImageTupleTransform']

# Cell
import gzip
from fastai.vision.all import *
import numpy as np
import pandas as pd


# train_t = pd.period_range(start='2020-01-01 01:00:00', end='2020-05-01 00:00:00', freq='H'),
# val_t = pd.period_range(start='2020-05-01 01:00:00', end='2020-06-01 00:00:00', freq='H'),
# test_t = pd.period_range(start='2020-06-01 01:00:00', end='2020-07-01 00:00:00', freq='H'),


# Cell
class PM:
    def __init__(self,
                 root,
                 in_len=5,
                 out_len=5,
                 type='train',
                 # t_range=pd.period_range(start='2020-06-01 01:00:00', end='2020-06-02 0:00:00', freq='H')
                 t_range=pd.period_range(start='2020-01-01 01:00:00', end='2020-11-01 0:00:00', freq='H')
                 ):
        data = np.load(root)
        self.pm25 = data['pm25']
        # self.pm25_max = self.pm25.max()
        self.pm25_max = 400
        self.t = data['t']
        self.in_len = in_len
        self.out_len = out_len
        self.seq_len = self.in_len + self.out_len
        self.wid, self.len = self.pm25.shape[1], self.pm25.shape[2]
        assert type in ['train', 'val', 'test']
        self.type = type
        self.t_range = t_range.to_timestamp().tz_localize("UTC").values
        self.idx_start = int(np.where(self.t == self.t_range[0])[0])
        self.idx_end = int(np.where(self.t == self.t_range[-1])[0] + 1)

        self.data = self._gen_sequence()

        self.length = self.data.shape[0]

        self.n_frames_input = self.in_len
        self.n_frames_output = self.out_len
        self.n_frames_total = self.seq_len

    def _gen_sequence(self):
        pm25_range = self.pm25[self.idx_start: self.idx_end]

        pm25_seq = []
        for i in range(self.seq_len):
            pm25_i = np.roll(pm25_range, -i, axis=0)
            # np.equal(np.roll(pm25_range, 0, axis=0)[1], np.roll(pm25_range, -1, axis=0)[0]).all()
            pm25_seq.append(pm25_i)
        pm25_seq = np.stack(pm25_seq, axis=1)[:-self.seq_len+1]

        return pm25_seq


    def __getitem__(self, idx):
        input = self.data[idx, :self.in_len, None, :, :]
        output = self.data[idx, -self.out_len:, None, :, :]
        output = torch.from_numpy(output / self.pm25_max).contiguous().float()
        input = torch.from_numpy(input / self.pm25_max).contiguous().float()

        return input, output


    def __len__(self):
        return self.length

# Cell
class ImageSeq(fastuple):
    @classmethod
    def create(cls, t, cl_type=TensorImageBW):
        return cls(tuple(cl_type(im) for im in t))
    def show(self, ctx=None, **kwargs):
        return show_image(torch.cat([t for t in self], dim=2), ctx=ctx, **self[0]._show_args, **kwargs)

# Cell
class ImageTupleTransform(Transform):
    def __init__(self, ds, cl_type=TensorImageBW):
        self.ds = ds
        self.cl_type = cl_type

    def encodes(self, idx):
        x,y = self.ds[idx]

        # for i in range(5):
            # plt.imshow(x[i, 0])
            # plt.show()
        return ImageSeq.create(x, self.cl_type), ImageSeq.create(y, self.cl_type)

# Cell
@typedispatch
def show_batch(x:ImageSeq, y:ImageSeq, samples, ctxs=None, max_n=6, nrows=None, ncols=2, figsize=None, **kwargs):
    if figsize is None: figsize = (ncols*6, max_n* 1.2)
    if ctxs is None:
        _, ctxs = plt.subplots(min(x[0].shape[0], max_n), ncols, figsize=figsize)
    for i,ctx in enumerate(ctxs):
        samples[i][0].show(ctx=ctx[0]), samples[i][1].show(ctx=ctx[1])

    # if figsize is None: figsize = (ncols*6, max_n* 1.2)
    # if ctxs is None:
    #     _, ctxs = plt.subplots(min(x[0].shape[0], max_n), ncols, figsize=figsize)
    # for i,ctx in enumerate(ctxs):
    #     samples[i][0].show(ctx=ctx[0]), samples[i][1].show(ctx=ctx[1])


def main():
    npz_fp = '/Users/wangshuo/Documents/workspace/data/air-quality/chengyun/pm2.5_data.npz'

    ds = PM(npz_fp)
    train_tl = TfmdLists(range(5), ImageTupleTransform(ds))
    valid_tl = TfmdLists(range(5), ImageTupleTransform(ds))

    dls = DataLoaders.from_dsets(train_tl, valid_tl, bs=5,
                                 after_batch=[Normalize.from_stats(imagenet_stats[0][0],
                                                                   imagenet_stats[1][0])]).cuda()

    dls.show_batch()


if __name__ == '__main__':
    main()
